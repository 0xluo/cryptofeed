<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>CryptoFeed</title>
  <meta name="description" content="Minimalist Crypto News Aggregator" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîç</text></svg>" />
  <style>
    /* =========================================
       1. Design Tokens (Flat & Clean)
       ========================================= */
    :root {
      /* Palette - Light */
      --bg-body: #f4f5f7;
      --bg-card: #ffffff;
      --bg-element: #eef0f3;
      --border: #e2e5e9;
      --text-main: #1a1d21;
      --text-sub: #848b96;
      --accent: #2972fa; /* Blue */
      
      /* Source Colors */
      --c-coindesk: #FDDC5B;
      --c-cointelegraph: #FBBD2F;
      --c-theblock: #291EFF;
      --c-decrypt: #000000;
      --c-delphi: #0a85c3;
      --c-bankless: #FF0000;
      --c-thedefiant: #00FF78;
      
      --radius: 10px;
      --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --shadow: 0 1px 2px rgba(0,0,0,0.04);
    }

    [data-theme="dark"] {
      /* Palette - Dark */
      --bg-body: #0d0f12;
      --bg-card: #16181c;
      --bg-element: #202328;
      --border: #2a2e35;
      --text-main: #eceef0;
      --text-sub: #8a919e;
      --shadow: none;
      /* Decrypt uses white in dark mode */
      --c-decrypt: #ffffff;
    }

    * { box-sizing: border-box; }
    
    body {
      margin: 0;
      font-family: var(--font);
      background-color: var(--bg-body);
      color: var(--text-main);
      line-height: 1.5;
      transition: background-color 0.3s, color 0.3s;
      padding-bottom: 60px;
    }

    a { text-decoration: none; color: inherit; }
    a:hover { color: var(--accent); }

    /* =========================================
       2. Header & Controls
       ========================================= */
    header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(var(--bg-body), 0.9);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--border);
      padding: 14px 0;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }

    .header-inner {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .logo {
      font-size: 24px;
      font-weight: 800;
      letter-spacing: -0.5px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .update-time {
      font-size: 12px;
      color: var(--text-sub);
      white-space: nowrap;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    /* Buttons & Toggles */
    .btn {
      background: var(--bg-element);
      border: 1px solid transparent;
      color: var(--text-main);
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }
    .btn:hover { background: var(--border); }
    .btn:active { transform: scale(0.96); }

    .toggle-group {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-sub);
      cursor: pointer;
      user-select: none;
    }
    .toggle-switch {
      width: 36px;
      height: 20px;
      background: var(--border);
      border-radius: 99px;
      position: relative;
      transition: background 0.3s;
    }
    .toggle-switch::after {
      content: "";
      position: absolute;
      top: 2px; left: 2px;
      width: 16px; height: 16px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
      transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    input[type="checkbox"] { display: none; }
    input:checked + .toggle-switch { background: var(--accent); }
    input:checked + .toggle-switch::after { transform: translateX(16px); }
    
    /* Theme toggle with sun/moon icons */
    #themeToggle + .toggle-switch::before {
      content: "‚òÄÔ∏è";
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 12px;
      transition: opacity 0.3s;
      z-index: 1;
    }
    #themeToggle:checked + .toggle-switch::before {
      content: "üåô";
      left: auto;
      right: 4px;
    }
    #themeToggle + .toggle-switch::after {
      z-index: 0;
    }

    /* =========================================
       3. Layout & Cards
       ========================================= */
    .section-head {
      margin: 30px 0 16px;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      border-bottom: 2px solid var(--border);
      padding-bottom: 8px;
    }
    .section-title {
      font-size: 16px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-main);
    }
    .section-meta {
      font-size: 12px;
      color: var(--text-sub);
      font-family: monospace;
    }

    /* Filter Buttons */
    .filter-group {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .filter-btn {
      background: var(--bg-element);
      border: 1px solid var(--border);
      color: var(--text-sub);
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    .filter-btn:hover {
      background: var(--border);
      color: var(--text-main);
    }
    .filter-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }
    @media (max-width: 768px) {
      .filter-group {
        margin-top: 8px;
        width: 100%;
      }
      .section-head {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    /* News Grid */
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 16px;
    }

    /* Research Columns */
    .research-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin-top: 10px;
    }
    @media (max-width: 768px) {
      .research-grid { grid-template-columns: 1fr; }
    }

    /* Card Style */
    .card {
      background: var(--bg-card);
      border-radius: var(--radius);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
      transition: transform 0.2s, box-shadow 0.2s;
      border: 1px solid transparent;
      height: 100%;
    }
    [data-theme="light"] .card { border-color: var(--border); }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow);
      border-color: var(--text-sub);
    }
    
    /* Source Badge */
    .badge {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--src-color, var(--text-sub));
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    .badge::before {
      content: "";
      width: 6px; height: 6px;
      border-radius: 50%;
      background: currentColor;
    }

    .card h3 {
      font-size: 15px;
      margin: 0;
      line-height: 1.4;
      font-weight: 600;
      /* Ensure text wraps nicely */
      word-break: break-word; 
    }
    
    .card p {
      margin: 0;
      font-size: 13px;
      color: var(--text-sub);
      line-height: 1.4;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .card-time {
      margin-top: auto;
      padding-top: 12px;
      font-size: 11px;
      color: var(--text-sub);
      opacity: 0.8;
    }

    /* Loading State */
    .spin { animation: spin 0.8s linear infinite; }
    @keyframes spin { 100% { transform: rotate(360deg); } }
    
    /* Status Bar */
    .status-bar {
      font-size: 12px;
      color: var(--text-sub);
      text-align: center;
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
    }
  </style>
</head>
<body data-theme="dark">

<header>
  <div class="container header-inner">
    <div class="logo">
      üîç Crypto Feed
    </div>

    <div class="controls">
      <span class="update-time" id="updateTime"></span>
      <label class="toggle-group" title="Auto Translate to Chinese">
        <input type="checkbox" id="translateToggle" checked>
        <div class="toggle-switch"></div>
        <span>‰∏≠ËØë</span>
      </label>

      <label class="toggle-group" title="Switch Theme">
        <input type="checkbox" id="themeToggle">
        <div class="toggle-switch"></div>
      </label>

      <button class="btn" id="refreshBtn">
        <svg id="refreshIcon" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M23 4v6h-6M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
        Refresh
      </button>
    </div>
  </div>
</header>

<main class="container">
  
  <div class="section-head">
    <div>
      <div class="section-title">Latest News</div>
      <div class="section-meta" id="newsCount">Loading...</div>
    </div>
    <div class="filter-group">
      <button class="filter-btn active" data-filter="all">All</button>
      <button class="filter-btn" data-filter="CoinDesk">CoinDesk</button>
      <button class="filter-btn" data-filter="CoinTelegraph">CoinTelegraph</button>
      <button class="filter-btn" data-filter="Decrypt">Decrypt</button>
      <button class="filter-btn" data-filter="The Block">The Block</button>
      <button class="filter-btn" data-filter="The Defiant">The Defiant</button>
    </div>
  </div>
  <div class="grid" id="newsGrid"></div>

  <div class="research-grid">
    <div>
      <div class="section-head">
        <div class="section-title" style="color:var(--c-delphi)">Delphi Digital</div>
        <div class="section-meta" id="delphiCount"></div>
      </div>
      <div class="grid" style="grid-template-columns: 1fr;" id="delphiGrid"></div>
    </div>
    
    <div>
      <div class="section-head">
        <div class="section-title" style="color:var(--c-bankless)">Bankless</div>
        <div class="section-meta" id="banklessCount"></div>
      </div>
      <div class="grid" style="grid-template-columns: 1fr;" id="banklessGrid"></div>
    </div>
  </div>

  <div class="status-bar">
    <a href="https://x.com/0xLuo" target="_blank" style="color: var(--text-sub); text-decoration: none;">build by 0xLuo</a>
  </div>

</main>

<script>
/**
 * CONFIGURATION
 */
const CONFIG = {
  sources: [
    { id: "coindesk", name: "CoinDesk", color: "#FDDC5B", url: "https://www.coindesk.com/arc/outboundfeeds/rss/?outputType=xml" },
    { id: "cointelegraph", name: "CoinTelegraph", color: "#FBBD2F", url: "https://cointelegraph.com/rss" },
    { id: "theblock", name: "The Block", color: "#291EFF", url: "https://www.theblock.co/rss.xml" },
    { id: "decrypt", name: "Decrypt", color: "#000000", url: "https://decrypt.co/feed" },
    { id: "thedefiant", name: "The Defiant", color: "#00FF78", url: "https://thedefiant.io/feed/" }
  ],
  // Use RSS for Bankless now (more stable than scraping)
  // Try multiple possible RSS URLs for Bankless
  banklessUrls: [
    "https://banklesshq.com/feed",
    "https://www.banklesshq.com/feed", 
    "https://bankless.com/feed",
    "https://www.bankless.com/rss"
  ],
  delphiUrl: "https://members.delphidigital.io/search",
  // Proxy rotation to bypass CORS
  proxies: [
    u => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
    u => `https://corsproxy.io/?${encodeURIComponent(u)}`
  ]
};

let STATE = {
  news: [],
  delphi: [],
  bankless: [],
  translate: true,
  currentFilter: "all"
};

const $ = s => document.querySelector(s);

/**
 * UTILITIES
 */
// Robust Fetch
async function fetchSafe(url) {
  for (const p of CONFIG.proxies) {
    try {
      const res = await fetch(p(url), { cache: "no-store" });
      if (res.ok) return await res.text();
    } catch(e) {}
  }
  console.warn("All proxies failed for:", url);
  return null;
}

// Time formatter
function timeAgo(ts) {
  if (!ts || ts === 0) return "";
  const diff = (Date.now() - ts) / 1000;
  if (diff < 0) return "recent"; // Future dates
  if (diff < 3600) return Math.floor(diff/60) + "m ago";
  if (diff < 86400) return Math.floor(diff/3600) + "h ago";
  if (diff < 2592000) return Math.floor(diff/86400) + "d ago";
  // For older items, show date
  const date = new Date(ts);
  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined });
}

/**
 * PARSERS
 */
function parseRSS(xmlStr, sourceName, color) {
  if (!xmlStr) {
    console.warn(`No XML content for ${sourceName}`);
    return [];
  }
  
  try {
    const doc = new DOMParser().parseFromString(xmlStr, "text/xml");
    
    // Check for parsing errors
    const parserError = doc.querySelector("parsererror");
    if (parserError) {
      console.warn(`RSS parsing error for ${sourceName}:`, parserError.textContent);
      return [];
    }
    
    const items = Array.from(doc.querySelectorAll("item"));
    if (items.length === 0) {
      console.warn(`No items found in RSS for ${sourceName}`);
      // Try alternative selectors (some RSS feeds use different structure)
      const entries = Array.from(doc.querySelectorAll("entry"));
      if (entries.length > 0) {
        return entries.map(entry => ({
          title: entry.querySelector("title")?.textContent || "",
          link: entry.querySelector("link")?.getAttribute("href") || entry.querySelector("link")?.textContent || "",
          ts: Date.parse(entry.querySelector("published")?.textContent || entry.querySelector("updated")?.textContent) || Date.now(),
          source: sourceName,
          color: color
        })).slice(0, 12);
      }
      return [];
    }
    
    return items.map(item => ({
      title: item.querySelector("title")?.textContent || "",
      link: item.querySelector("link")?.textContent || "",
      ts: Date.parse(item.querySelector("pubDate")?.textContent) || Date.now(),
      source: sourceName,
      color: color
    })).slice(0, 12);
  } catch (e) {
    console.error(`Error parsing RSS for ${sourceName}:`, e);
    return [];
  }
}

// Delphi HTML Parser
function parseDelphi(html) {
  if (!html) return [];
  const doc = new DOMParser().parseFromString(html, "text/html");
  // Look for links that contain '/reports/'
  const links = Array.from(doc.querySelectorAll('a[href*="/reports/"]'));
  const seen = new Set();
  const results = [];
  
  links.forEach(a => {
    const title = a.textContent.trim();
    let link = a.getAttribute("href");
    if (link.startsWith("/")) link = "https://members.delphidigital.io" + link;
    
    if (title.length > 10 && !seen.has(link)) {
      seen.add(link);
      
      // Try to find date/time information near the link
      let ts = Date.now(); // Default to now
      
      // Look for date in parent or nearby elements
      let parent = a.parentElement;
      let dateFound = false;
      
      // Try to find date in common patterns
      for (let i = 0; i < 3 && parent && !dateFound; i++) {
        // Look for time elements, date attributes, or text that looks like dates
        const timeEl = parent.querySelector('time');
        if (timeEl) {
          const datetime = timeEl.getAttribute('datetime') || timeEl.textContent;
          if (datetime) {
            ts = Date.parse(datetime) || ts;
            dateFound = true;
            break;
          }
        }
        
        // Look for date-like text in siblings or parent
        const text = parent.textContent || '';
        // Try to match common date patterns (e.g., "Jan 15, 2024", "2024-01-15", etc.)
        const dateMatch = text.match(/\b(\d{4}[-/]\d{1,2}[-/]\d{1,2})\b/) || 
                         text.match(/\b([A-Z][a-z]{2,8}\s+\d{1,2},?\s+\d{4})\b/);
        if (dateMatch) {
          ts = Date.parse(dateMatch[1]) || ts;
          dateFound = true;
          break;
        }
        
        parent = parent.parentElement;
      }
      
      // If no date found, try to extract from URL or use a reasonable default
      if (!dateFound) {
        // Try to extract date from URL if it contains date patterns
        const urlDateMatch = link.match(/\/(\d{4})\/(\d{1,2})\/(\d{1,2})\//);
        if (urlDateMatch) {
          const [, year, month, day] = urlDateMatch;
          ts = Date.parse(`${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`) || ts;
        } else {
          // Use a decreasing timestamp based on order (newer items first)
          // Assume items are roughly ordered by recency, with most recent being ~1 day old
          ts = Date.now() - (seen.size * 86400000 * 0.5); // Subtract ~0.5 days per item
        }
      }
      
      results.push({
        title, link, ts, 
        source: "Delphi", color: "#0a85c3"
      });
    }
  });
  
  // Sort by timestamp (newest first) and return top 10
  return results.sort((a, b) => b.ts - a.ts).slice(0, 10);
}

/**
 * BULK TRANSLATION (KEY FIX)
 * Sends multiple titles in one request to ensure all get translated
 * and to be faster/friendlier to the API.
 */
async function bulkTranslate(items) {
  if (!STATE.translate || items.length === 0) return items;

  // 1. Create a big string with a unique separator
  const separator = " ||| "; 
  // Google Translate URL limit is roughly 2k-5k chars. Split into chunks if needed.
  // We'll process in chunks of 30 items to be safe.
  const chunkSize = 30;
  
  for (let i = 0; i < items.length; i += chunkSize) {
    const chunk = items.slice(i, i + chunkSize);
    const textBlock = chunk.map(x => x.title).join(separator);
    
    try {
      const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=zh-CN&dt=t&q=${encodeURIComponent(textBlock)}`;
      const res = await fetch(url);
      const data = await res.json();
      
      // data[0] contains the translated segments. We need to join them back and split by separator.
      // Note: Google sometimes breaks the separator or adds spaces.
      // A more robust way: map the segments directly if structure allows.
      // Usually data[0] is array of [trans, orig].
      
      const fullTranslatedText = data[0].map(x => x[0]).join("");
      
      // Regex split to handle potential spacing changes around |||
      const translatedTitles = fullTranslatedText.split(/\s*\|\|\|\s*/);
      
      // Assign back
      chunk.forEach((item, idx) => {
        if (translatedTitles[idx]) {
          item.titleZh = translatedTitles[idx].trim();
        }
      });
      
    } catch (e) {
      console.error("Translation chunk failed", e);
    }
  }
  return items;
}

/**
 * CORE LOGIC
 */
async function loadAll() {
  const btnIcon = $("#refreshIcon");
  btnIcon.classList.add("spin");
  $("#updateTime").textContent = "";

  try {
    // 1. Fetch News (Parallel)
    const newsPromises = CONFIG.sources.map(src => 
      fetchSafe(src.url).then(xml => parseRSS(xml, src.name, src.color))
    );
    
    // 2. Fetch Research (Parallel)
    // Try multiple Bankless RSS URLs until one works
    let banklessData = [];
    for (const url of CONFIG.banklessUrls) {
      try {
        const xml = await fetchSafe(url);
        if (xml) {
          const allItems = parseRSS(xml, "Bankless", "#FF0000");
          // Sort by timestamp and take top 10
          banklessData = allItems.sort((a, b) => b.ts - a.ts).slice(0, 10);
          if (banklessData.length > 0) {
            console.log(`Bankless RSS loaded from: ${url}`);
            break;
          }
        }
      } catch (e) {
        console.warn(`Bankless URL failed: ${url}`, e);
      }
    }
    
    const delphiPromise = fetchSafe(CONFIG.delphiUrl)
      .then(html => parseDelphi(html));

    const results = await Promise.all([...newsPromises, Promise.resolve(banklessData), delphiPromise]);

    // Flatten News
    STATE.news = results.slice(0, 5).flat().sort((a,b) => b.ts - a.ts);
    // Extract Bankless & Delphi
    STATE.bankless = results[5] || []; 
    STATE.delphi = results[6] || [];

    // 3. Translate Everything
    if (STATE.translate) {
      // We create a master list of references to translate
      const allItems = [...STATE.news, ...STATE.bankless, ...STATE.delphi];
      await bulkTranslate(allItems);
    }

    render();
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    const updateTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    $("#updateTime").textContent = updateTime;

  } catch (e) {
    console.error("Load error:", e);
    
    // Ensure arrays are initialized even on error
    if (!STATE.bankless) STATE.bankless = [];
    if (!STATE.delphi) STATE.delphi = [];
    if (!STATE.news) STATE.news = [];
    
    render(); // Still render what we have
  } finally {
    btnIcon.classList.remove("spin");
  }
}

function render() {
  // Helper to make cards
  const mkCard = (item) => {
    const displayTitle = (STATE.translate && item.titleZh) ? item.titleZh : item.title;
    const subTitle = (STATE.translate && item.titleZh) ? item.title : "";
    
    // Handle Decrypt color based on theme
    let itemColor = item.color;
    if (item.source === "Decrypt") {
      const isDark = document.body.getAttribute("data-theme") === "dark";
      itemColor = isDark ? "#ffffff" : "#000000";
    }
    
    return `
      <a href="${item.link}" target="_blank" class="card" style="--src-color:${itemColor}">
        <div class="badge">${item.source}</div>
        <h3>${displayTitle}</h3>
        ${subTitle ? `<p>${subTitle}</p>` : ''}
        <div class="card-time">${timeAgo(item.ts)}</div>
      </a>
    `;
  };

  // Filter news based on current filter
  let filteredNews = STATE.news;
  if (STATE.currentFilter !== "all") {
    filteredNews = STATE.news.filter(item => item.source === STATE.currentFilter);
  }

  $("#newsGrid").innerHTML = filteredNews.map(mkCard).join("");
  $("#newsCount").textContent = `${filteredNews.length} items`;

  $("#delphiGrid").innerHTML = STATE.delphi.map(mkCard).join("");
  $("#delphiCount").textContent = `${STATE.delphi.length}`;

  // Ensure bankless is an array before mapping
  const banklessItems = Array.isArray(STATE.bankless) ? STATE.bankless : [];
  $("#banklessGrid").innerHTML = banklessItems.length > 0 
    ? banklessItems.map(mkCard).join("") 
    : '<div class="card"><p style="color:var(--text-sub)">No content available. Try refreshing.</p></div>';
  $("#banklessCount").textContent = `${banklessItems.length}`;
}

/**
 * EVENTS
 */
$("#refreshBtn").addEventListener("click", loadAll);

$("#translateToggle").addEventListener("change", (e) => {
  STATE.translate = e.target.checked;
  // If turning on, we might need to fetch/translate again if we didn't save it.
  // For simplicity, we just reload.
  loadAll();
});

// Initialize theme toggle based on current theme
const themeToggle = $("#themeToggle");
const body = document.body;
const isDark = body.getAttribute("data-theme") === "dark";
themeToggle.checked = isDark;

$("#themeToggle").addEventListener("change", (e) => {
  const body = document.body;
  // Toggle checked means dark mode, unchecked means light mode
  body.setAttribute("data-theme", e.target.checked ? "dark" : "light");
  // Re-render to update Decrypt color based on theme
  render();
});

// Filter buttons
document.querySelectorAll(".filter-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    // Update active state
    document.querySelectorAll(".filter-btn").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    
    // Update filter
    STATE.currentFilter = btn.getAttribute("data-filter");
    
    // Re-render news
    render();
  });
});

// Init
loadAll();

</script>
</body>
</html>